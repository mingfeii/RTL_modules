%一个加法器：
% 输入a Q3.4 8位，有符号 （加上符号位）
%输入 b Q2.3 6位，有符号
%输出：c = a + b, c为Q3.1  带符号，位宽为5，需要做四舍五入，4.35 =》 4.4 就是把小数点第二位舍入到第一位上

% 如果最后能实现，那么实现精度就是0.25 . 因为是小数点后两个bit 1/2^2 = 0.25


%分析整数部分的结构是3个bit加两个bit,扩展成一样就是至少4个bit，要求3个bit
%那么要做溢出保护


%%%%%%%%%%%%%%%%%%%%%%%%%%

% a : 3 位整数，4位小数，有符号 8位
% b : 2 位整数，3位小数，有符号 8位
% c : 限定 3位整数，1位小数，有符号（要求四舍五入输出），位宽共5位

function c = plus_signed(a,b)


% a 定点化， 位宽7位
a2 = floor(a * 2^4);

% 限定a2 最大值
if a2 > 2^7 - 1
    a2 = a2 - 2^8 ;
elseif a2 < -2^7
    a2 = a2 + 2^8;
end 

% b定点化，位宽与a对齐，位宽7位
b2 = floor(b * 2^3) * 2; 

%限定  b2 最大值
if b2 > 2^6 - 1
    b2 = b2 - 2^7;
elseif b2 < -2^6
    b2 = b2 + 2^7;
end 


%c2 : 4位小数，4位整数，有符号，位宽9位(4 + 4 + 1sign)
c2 = a2 + b2;

%限定c2最大值
if c2 > 2^8 - 1
    c2 = c2 - 2^9;
elseif c2 < -2^8
    c2 = c2 + 2^9;
end 



%这样输出 就是Q4.4,但是要求1位小数输出，所以要截掉后面3位 c2 >> 3,又因为要四舍五入：
% 1. 计算结果保留一位小数
% 2. 在数值上加一
% 3. 正常截取小数部分，只保留整数

% 那么需要移掉2位 ： (c2 >> 2 + 1) + 1 

% c3： 位宽8位，2位小数，5位整数，有符号
c3 = floor(c2 / 2^2) + 1;

%限定c3最大值
if c3 > 2^7 - 1
    c3 = c3 - 2^8;
elseif c3 < -2^7
    c3 = c3 + 2^8;
end 

% c4 有符号，缩为7位
c4 = floor(c3 / 2); %对应上面


%c溢出保护 (Q)

if  c4 > 2^4 - 1
    c = 2^4 - 1;
elseif c4 < -2^4
    c = -2^4;
else 
    c = c4;
end 


%c 暗含了一位小数
%非RTL的部分

c = c / 2;


end 